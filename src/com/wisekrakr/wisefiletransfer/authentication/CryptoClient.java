package com.wisekrakr.wisefiletransfer.authentication;


import com.wisekrakr.wisefiletransfer.Constants;
import com.wisekrakr.wisefiletransfer.util.Messenger;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public abstract class CryptoClient extends Thread{

    private String privateKeyFilePath;
    private String certFilePath;

    public CryptoClient(String privateKeyFilePath, String certFilePath) {
        this.privateKeyFilePath = privateKeyFilePath;
        this.certFilePath = certFilePath;
    }

    public CryptoClient() {
    }

    public KeyPair generateKeyPair(){
        try {
            //Create key generator (RSA asymmetric encryption)
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            //Use 1024 bit keys
            keyGen.initialize(Constants.KEY_SIZE);
            //Generate keyPair
            return keyGen.generateKeyPair();
        }catch (Throwable t){
            throw new IllegalStateException("Could not generate keypair",t);
        }
    }

    /**
     * Generates a private key with PKCS8 encoding.
     * @return a private key generated by a key factory
     */
    public PrivateKey privateKey() {
        final Path keyPath = Paths.get(privateKeyFilePath);

        try {
            byte[] privateKeyByteArray = Files.readAllBytes(keyPath);
            PKCS8EncodedKeySpec PKCS8privateKey = new PKCS8EncodedKeySpec(privateKeyByteArray);
            KeyFactory keyFactory = KeyFactory.getInstance(Constants.RSA);

            return keyFactory.generatePrivate(PKCS8privateKey);
        }catch (Throwable t){
            throw new IllegalStateException("Could not generate private key",t);
        }

    }

    public Cipher rsaCryptoCipher() throws NoSuchPaddingException, NoSuchAlgorithmException {
        return Cipher.getInstance(Constants.RSA_ECB_PADDING);
    }

    /**
     * Generates a public key with X509 encoding.
     * @return a public key generated by a key factory
     */
    public PublicKey getPublicKey(String key){
        try{
            byte[] byteKey = Base64.getDecoder().decode(key);
            X509EncodedKeySpec X509publicKey = new X509EncodedKeySpec(byteKey);
            KeyFactory keyFactory = KeyFactory.getInstance(Constants.RSA);

            return keyFactory.generatePublic(X509publicKey);
        }catch(Throwable t){
            throw new IllegalStateException("Could not generate new public key",t);
        }
    }

    public Key getAESKey(String AESKeyString, Cipher rsaDCipher) {
        byte[] byteKey = DatatypeConverter.parseBase64Binary(AESKeyString);
        byte[] decryptedByteKey;
        try {
            decryptedByteKey = rsaDCipher.doFinal(byteKey);
        }catch (Throwable t){
            throw new IllegalStateException("Could not get AES Key",t);
        }
        return new SecretKeySpec(decryptedByteKey, 0, decryptedByteKey.length, Constants.AES);
    }

    /**
     * Generates secret key using AES algorithm, encrypt it with server's public key, send it to server
     * @param rsaECipherServerPublic Cipher for encryption
     * @param out PrintWriter to send messages with
     * @return a key to send with files
     */
    public SecretKey getSecretKey(Cipher rsaECipherServerPublic, PrintWriter out){
        SecretKey key;
        try {
            key = KeyGenerator.getInstance(Constants.AES).generateKey();
            byte[] encryptedKey = rsaECipherServerPublic.doFinal(key.getEncoded());
            Messenger.sendMsg(out, DatatypeConverter.printBase64Binary(encryptedKey));
        }catch (Throwable t){
            throw new IllegalStateException("Could not generate secret key",t);
        }
        return key;
    }
}
