package com.wisekrakr.wisefiletransfer.authentication;


import com.wisekrakr.wisefiletransfer.Constants;
import com.wisekrakr.wisefiletransfer.util.Messenger;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

/**
 * Abstract class that handles multiple important operations for a Secure connection.
 * All necessary steps for key generating to encrypting keys can be found in this class.
 * A Client should extend this class so that it can simple reference these methods for easy use.
 */
public abstract class CryptoClient extends Thread{

    private String privateKeyFilePath;
    private String certFilePath;
    private byte[] encryptedKey;

    public CryptoClient(String privateKeyFilePath, String certFilePath) {
        this.privateKeyFilePath = privateKeyFilePath;
        this.certFilePath = certFilePath;
    }

    public CryptoClient() {
    }

    /**
     * Creates a key generator (RSA asymmetric encryption) and uses 2048 bit keys
     * Generates a key pair
     * @return new made key pair
     */
    public KeyPair generateKeyPair(){
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(Constants.RSA);
            keyGen.initialize(Constants.KEY_SIZE);
            return keyGen.generateKeyPair();
        }catch (Throwable t){
            throw new IllegalStateException("Could not generate keypair",t);
        }
    }

    /**
     * Generates a private key with PKCS8 encoding.
     * @return a private key generated by a key factory
     */
    public PrivateKey privateKey() {
        final Path keyPath = Paths.get(privateKeyFilePath);

        try {
            byte[] privateKeyByteArray = Files.readAllBytes(keyPath);
            PKCS8EncodedKeySpec PKCS8privateKey = new PKCS8EncodedKeySpec(privateKeyByteArray);
            KeyFactory keyFactory = KeyFactory.getInstance(Constants.RSA);

            return keyFactory.generatePrivate(PKCS8privateKey);
        }catch (Throwable t){
            throw new IllegalStateException("Could not generate private key",t);
        }

    }

    /**
     * @return New Cipher instance with "RSA/ECB/PKCS1Padding" cryptography for encryption and decryption
     * @throws NoSuchPaddingException
     * @throws NoSuchAlgorithmException
     */
    public Cipher rsaCryptoCipher() throws NoSuchPaddingException, NoSuchAlgorithmException {
        return Cipher.getInstance(Constants.RSA_ECB_PADDING);
    }

    /**
     * Generates a public key with X509 encoding.
     * @return a public key generated by a key factory
     */
    public PublicKey getPublicKey(String key){
        try{
            byte[] byteKey = Base64.getDecoder().decode(key);
            X509EncodedKeySpec X509publicKey = new X509EncodedKeySpec(byteKey);
            KeyFactory keyFactory = KeyFactory.getInstance(Constants.RSA);

            return keyFactory.generatePublic(X509publicKey);
        }catch(Throwable t){
            throw new IllegalStateException("Could not generate new public key",t);
        }
    }

    /**
     * Used to construct a SecretKey from a byte array
     * @param AESKeyString string send by another party
     * @param rsaDCipher a Cipher instance for decryption
     * @return a secret key from the given byte array, using the first len bytes of key, starting at offset inclusive.
     */
    public Key getAESKey(String AESKeyString, Cipher rsaDCipher) {
        byte[] byteKey = DatatypeConverter.parseBase64Binary(AESKeyString);
        byte[] decryptedByteKey;
        try {
            decryptedByteKey = rsaDCipher.doFinal(byteKey);
        }catch (Throwable t){
            throw new IllegalStateException("Could not get AES Key",t);
        }
        return new SecretKeySpec(decryptedByteKey, 0, decryptedByteKey.length, Constants.AES);
    }

    /**
     * Generates secret key using AES algorithm, encrypt it with server's public key, send it to server
     * @param rsaECipherServerPublic Cipher for encryption
     * @return a key to send with files
     */
    public SecretKey getSecretKey(Cipher rsaECipherServerPublic){
        SecretKey key;
        try {
            key = KeyGenerator.getInstance(Constants.AES).generateKey();
            encryptedKey = rsaECipherServerPublic.doFinal(key.getEncoded());

        }catch (Throwable t){
            throw new IllegalStateException("Could not generate secret key",t);
        }
        return key;
    }

    /**
     * Byte array from an encrypted secret key
     * @return encrypted key byte array
     */
    public byte[] getEncryptedKey() {
        return encryptedKey;
    }
}
